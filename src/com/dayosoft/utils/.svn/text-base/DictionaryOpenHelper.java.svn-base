package com.dayosoft.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Vector;

import com.dayosoft.quicknotes.Note;
import com.dayosoft.quicknotes.NoteMeta;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class DictionaryOpenHelper extends SQLiteOpenHelper {

	private static final int DATABASE_VERSION = 2;
	private static final String DATABASE_NAME = "QUICKNOTES";
	private static final String DICTIONARY_TABLE_NAME = "notes";
	private static final String DICTIONARY_TABLE_CREATE = "CREATE TABLE "
			+ DICTIONARY_TABLE_NAME
			+ " ( ID INTEGER PRIMARY KEY ASC, TITLE TEXT, "
			+ " CONTENT TEXT, DATE_CREATED DATE DEFAULT CURRENT_TIMESTAMP, DATE_UPDATED DATE);";

	public DictionaryOpenHelper(Context context) {
		super(context, DATABASE_NAME, null, DATABASE_VERSION);
	}

	@Override
	public void onCreate(SQLiteDatabase db) {
		onUpgrade(db, 0, DATABASE_VERSION);
	}

	public int update(Note note) {
		ContentValues newValues = new ContentValues();
		newValues.put("TITLE", note.getTitle());
		newValues.put("CONTENT", note.getContent());
		return getWritableDatabase().update("notes", newValues,
				"id=" + note.getId(), null);
	}

	public List<Note> listNotes() {
		return listNotes(null);
	}
	
	public List<Note> listNotes(String query) {
		Vector<Note> returnList = new Vector<Note>();

		String columns[] = { "id", "title", "content", "date_created" };

		String whereClause = null;
		if (query != null) {
			whereClause = "title LIKE '%" + query + "%'";
		}
		Cursor notelist = getReadableDatabase().query("notes", columns,
				whereClause, null, null, null, "date_created DESC LIMIT 100");
		if (notelist.moveToFirst()) {
			// Iterate over each cursor.
			do {
				Note note = new Note();
				note.setId(notelist.getInt(0));
				note.setTitle(notelist.getString(1));
				note.setContent(notelist.getString(2));
				SimpleDateFormat dateformat = new SimpleDateFormat(
						"yyyy-MM-dd HH:mm:ss");
				try {
					note.setDate_created(dateformat.parse(notelist.getString(3)));
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				getMeta(note);
				returnList.add(note);
			} while (notelist.moveToNext());
		}
		return returnList;
	}

	public void getMeta(Note note) {
		SQLiteDatabase db = getReadableDatabase();
		String meta_columns[] = { "id", "note_id", "meta_type", "resource_url" };
		Cursor metalist = db.query("NOTE_META", meta_columns,
				"note_id=" + note.getId(), null, null, null, null);
		if (metalist.moveToFirst()) {
			do {
				NoteMeta meta = new NoteMeta();
				meta.setType(metalist.getInt(2));
				meta.setResource_url(metalist.getString(3));
				note.addMeta(meta);
			} while (metalist.moveToNext());
		}
		metalist.close();
	}

	public Note load(int id) {
		String columns[] = { "id", "title", "content", "date_created" };
		SQLiteDatabase db = getReadableDatabase();
		Cursor notelist = db.query("notes", columns, "id=" + id, null, null,
				null, "date_created DESC LIMIT 100");
		if (notelist.moveToFirst()) {
			Note note = new Note();
			note.setId(id);
			note.setTitle(notelist.getString(1));
			note.setContent(notelist.getString(2));
			SimpleDateFormat dateformat = new SimpleDateFormat(
					"yyyy-MM-dd HH:mm:ss");
			try {
				note.setDate_created(dateformat.parse(notelist.getString(3)));
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			getMeta(note);

			return note;
		}
		notelist.close();
		return null;
	}

	public void persist(Note note) {
		ContentValues newValues = new ContentValues();
		if (note.getTitle() == null || note.getTitle().trim().equals("")) {
			String content = note.getContent();
			if (content.length() > 20) {
				content = content.substring(0, 20);
			}
			if (content.indexOf("\n") != -1) {
				content = content.substring(0, content.indexOf("\n"));
			}

			note.setTitle(content);
		}
		newValues.put("TITLE", note.getTitle());
		newValues.put("CONTENT", note.getContent());
		SimpleDateFormat dateformat = new SimpleDateFormat(
				"yyyy-MM-dd HH:mm:ss");
		newValues.put("DATE_CREATED", dateformat.format(new Date()));
		SQLiteDatabase db = getWritableDatabase();
		long row_id = db.insert("notes", null, newValues);

		for (NoteMeta meta : note.getMeta()) {
			ContentValues metaNewValues = new ContentValues();
			metaNewValues.put("NOTE_ID", row_id);
			metaNewValues.put("META_TYPE", meta.getType());
			metaNewValues.put("RESOURCE_URL", meta.getResource_url());
			db.insert("NOTE_META", null, metaNewValues);
		}
		db.close();
	}

	public void delete(int id) {
		SQLiteDatabase db = getWritableDatabase();
		db.delete("notes", "id=" + id, null);
		db.delete("NOTE_META", "NOTE_ID=" + id, null);
		db.close();
	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldversion, int newversion) {
		// TODO Auto-generated method stub
		for (int version = oldversion; version <= newversion; version++) {
			switch (version) {
			case 1:
				db.execSQL(DICTIONARY_TABLE_CREATE);
				break;
			case 2:
				String sqlStr1 = "CREATE TABLE NOTE_META"
						+ " ( ID INTEGER PRIMARY KEY ASC, NOTE_ID INTEGER, "
						+ " META_TYPE INTEGER, RESOURCE_URL TEXT);";
				db.execSQL(sqlStr1);
				String sqlStr2 = "ALTER TABLE NOTES ADD COLUMN LONGTITUDE REAL";
				String sqlStr3 = "ALTER TABLE NOTES ADD COLUMN LATITUDE REAL";
				db.execSQL(sqlStr2);
				db.execSQL(sqlStr3);
				break;
			}
		}
	}
}
